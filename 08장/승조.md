# 8장. URL 단축기 설계

기초적인 URL 단축기 시스템의 기능은 다음과 같다:

- URL 단축: 주어진 긴 URL을 훨씬 짧게 줄인다.
- URL 리디렉션: 축약된 URL로 HTTP 요청이 오면 원래 URL로 리디렉션
- 높은 가용성과 규모 확장성, 그리고 장애 감내 요구

## 개략적 설계안

> API 엔드포인트, URL 리디렉션, URL 단축 플로에 대해 살펴보자.

### API 엔드포인트

URL 단축기의 기본적인 두 개의 엔드포인트:

**1. URL 단축용 엔드포인트 (POST)**

새 단축 URL 생성을 위해 해당 엔드포인트에 단축할 URL을 인자로 함께 전달한다.

```http request
POST /api/v1/data/shorten
```

- 인자: { longUrl: longUrlString }
- 반환: { shortUrl: srtUrl }

**2. URL 리디렉션용 엔드포인트 (GET)**

```http request
GET /api/v1/shortUrl
```

- 반환: HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션

301 리디렉션은 응답의 Location 헤더에 원래 URL을 포함하여 반환한다.

여기서 간단하게 301 vs 302 응답의 차이를 살펴보자.

- 301 Permanently Moved:
    - 이 응답은 URL에 대한 HTTP 요청의 처리 책임이 **영구적으로** Location 헤더에 반환된 URL로 이전되었다는 응답이다.
    - 브라우저는 이 응답을 캐시(cache)하여 추후 같은 요청을 보낼 필요가 있을 때 캐시된 응답을 사용한다.
    - 서버의 부하를 줄일 수 있지만, 트래픽 분석을 하기는 어렵다.
- 302 Found:
    - 이 응답은 주어진 URL로의 요청이 '일시적'으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다.
    - 클라이언트의 요청은 항상 단축 URL 서버에 먼저 보내진 후 원래 URL로 리디렉션 된다.

### URL 단축

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것이다.

- 원래 URL = hashTable.get(shortUrl)
- 301 or 302 응답 Location Header에 원래 URL을 포함하여 전송

당연하게도, 긴 URL을 해시 값으로 대응시킬 해시 함수(fx)를 찾는 일이 중요하다.

## 상세 설계

### 데이터 모델

<단축 URL, 원래 URL> 의 순서 쌍을 RDBMS에 저장한다면?

```mysql
CREATE TABLE url
(
    id       INTEGER PRIMARY KEY AUTO_INCREMENT,
    shortURL VARCHAR(255) NOT NULL,
    longURL  VARCHAR(255) NOT NULL
);
```

### 해시 함수

해시값은 [0-9, a-z, A-Z]의 문자들로 구성될 것이다. 따라서 사용할 수 있는 문자는 10 + 26 + 26 = 62개로, URL 길이만큼 제곱된 경우의 수가 나온다.

#### 1. 해시 후 충돌 해소

> 이거 뭔가 내가 지금까지 해왔던 방식이랑 비슷해보이네?

- 단축 URL을 생성할 때 한 번 이상 데이터베이스 쿼리를 실행해야 하여 오버헤드가 크다. (&larr; 내가 걱정했던 부분!)
- 블룸 필터를 사용하면 성능을 높일 수 있다고 한다.

#### 2. Base62 인코딩

- 62진법을 사용하여 해시값에 사용할 수 있는 문자를 만드는 것이다.
- 우리가 사용할 수 있는 문자는 62개이므로 적합한 진법 변환 방법이다.

## 마무리

더 나아가서, 처리율 제한 장치, 서버/데이터베이스 규모 확장, 가용성, 데이터 일관성, 안정성 등을 고려한다면 어떻게 시스템을 설계해야할 지 이전의 내용들을 살펴보자.

---

그렇게 어려워보이지는 않은 내용같은데 한 번 실제로 만들어서 배포해봐도 재밌을 것 같다. 
