# 8장. URL 단축기 설계


## 설계 범위
- 매일 1억개의 단축 URL 생성
- 단축 URL인만큼 길이는 짧은수록 좋다.
- URL에 포함될 문자는 숫자와 영문자
- 생성된 단축 URL은 지우거나 수정할 수 없다.

## 개략적 추정
- 한번 생성하고, 지속적으로 사용하는 시스템이기 때문에 쓰기 연산 대비 읽기 연산의 비율이 매우 높다.
- 10년 간 서비스를 운영한다고 했을 때 1억 x 365 x 10 = 3650억개의 레코드를 저장할 공간이 필요하다.  
- 축약 전 레코드의 평균 길이를 100바이트 정도라고 했을 때 3650억 x 100바이트 = 36.5TB 정도가 필요하다.
- 단축 후 데이터도 저장해야하고, 추가적인 데이터를 고려해본다면 3650억 x 20바이트 = 7~8TB 정도가 더 필요할 것이다. (이 수치는 설계에 따라 달라진다)

## API 엔드포인트
- URL 단축용 엔드포인트 : 긴 URL을 단축 URL로 만들 엔드포인트가 필요하다.
- URL 리디렉션용 엔드포인트 : 단축 URL로 조회 요처을 했을 때 원래 URL을 반환해줄 리디렉션 엔드포인트가 필요하다.

### 리디렉션 종류 선택
- 301 permanently Moved: 이 리디렉션은 영구적으로 URL을 옮기는 리디렉션이다.  
 영구적으로 옮겨가기 때문에 첫 번쨰 요청을 제외하고는 모두 원래 URL로만 요청이 간다. 그래서 서버 부하가 줄어든다.

- 302 Not Found: 이 리디렉션은 임시적으로 URL을 옮기는 리디렉션이다.  
임시적으로 옮겨가기 때문에 요청이 올 때 단축 URL을 겨쳐서 온다. 301 상태코드에 비해서 부하가 더 생길 수는 있지만 클릭 발생률을 추적하는 데 좀 더 유리하다.


## URL단축 전략
단축 URL은 숫자와 영어만 가능하므로 한 자리에 62개(0-9, a-z, A-Z)의 문자가 올 수 있다.  
여기서는 총 3650억개의 단축 URL을 만들어야 하므로 최소 62^7 = 3.5조개로 7자리 URL을 만들어야한다.
### 해시 후 충돌 해소 방법
원래 URL에 해시 함수를 적용하면 가장 짧은 해시값조차도 7자리보다 길어지게 된다.  
그렇다고 해서 길어진 해시값을 7자리에 맞춰서 충돌이 발생하기 때문에 데이터 존재 유무를 따져서 쿼리문을 다시 보내야한다.  
그런데 이렇게 되면 데이터가 쌓일수록 중복 확률이 높아서 재질의를 하는 빈도가 높아질 것이다.

### base-62 변환
식별키를 62진법으로 변환하는 방식이다.  
예를 들면 11157이라는 숫자는 2TX로 변환된다. 이 방식은 변환 전값과 변환 후 값이 1대1 대응이 되기 때문에 충돌이 발생하지 않는다.

### 비교
|                 해시 후 충돌 해소 전략                 |               base-62 변환               |
|:---------------------------------------------:|:--------------------------------------:|
|                단축 URL의 길이가 고정됨                |     단축 URL 길이가 가변적. ID 값에 비례하여 길어짐     |
|           유일성이 보장되는 ID 생성기가 필요치 않음            |            유일성 보장 ID 생성기 필요            |
|              충돌이 가능해서 해소 전략이 필요               |  ID의 유일성이 보장된 후에야 적용 가능한 전략이라 충돌은 불가능  |
| 긴 URL로부터 해시함수로 단축 URL을 생성하기 떄문에 다음 URL 추측 불가능 | ID가 1씩 증가하는 경우라고 가정할 떄 다음 단축 URL 추측 가능 |

> 데이터베이스에 데이터를 저장할 떄 키의 후보가 식별이 된다고 할지라도 비즈니스 로직에 쓰이는 칼럼을 ID로 채택하는 것은 위험하다.  
> 그렇기 떄문에 인조키를 설정하는 것이 보편적이다.   
> 이런 측면에서 ID 생성기가 필요하지 않다고 해서 해시 후 충돌 전략을 선택하는건 바람직하지 않다.  
> 또한 시간이 흐를수록 충돌 가능성이 높아지기 때문에 base-62 변환법이 성능적으로 유리하다.  
> URL의 다음값을 추측할 수 있더라도 그 추측이 서비스에 영향을 줄 것 같지는 않다. 이 부분이 염려된다면 앞에서 배웠던 스노우 플레이크 방식을 사용하는 것도 좋은 방법일 것 같다.  
> 어차피 분산 환경에서 URL 단축기 설계를 한다면 ID 생성기는 스노우 플레이크 혹은 UUID를 채택하는 것이 합리적이라고 생각한다.


> 생성할 수 있는 단축 URL이 한정되어 있는만큼 앞장에서 배웠던 처리율 제한 장치의 필요성이 느껴진다.
> 또한 분산환경을 염두에 둔다면 ID 생성 전략도 신경써야하는데 이 부분도 생각하게 된다.
> 조회 요청이 중요한 서비스인만큼 캐시에 저장하는 것도 중요한 것 같다. 

