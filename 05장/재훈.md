# 5장. 안정 해시 설계

서비스의 규모가 성장해서 Scale Out을 해야하는 시점이 왔다고 가정해보자.  
서버의 개수를 늘리게 될 때 중요한 것은 데이터를 각 서버에 균등하게 나누는 것이다.  

## 어떻게 균등하게 나눌 수 있을까?
가장 보편적인 방법은 키값에 해시함수를 적용하여 서버의 개수로 나누는 것이다.  
여기서 키값은 각 데이터를 식별할 수 있는 고유한 식별자를 말한다.  

**serverIndex = hash(key) % N (N은 서버의 개수이다.)**

## 모듈러 해싱의 문제점

### 서버를 추가시켰을 때
이 방식은 서버의 개수가 고정되어 있을 때는 잘 작동한다.  
하지만 서버의 개수를 늘린다면 어떻게 될까?  
기존의 서버의 개수가 3이었다가 4로 증가하면 나눠지는 분모가 달라지기 때문에 기존에 연결되었던 서버와 다른 위치로 연결될 수 있다.  
예를 들어서 해시함수를 적용한 값이 5라고 한다면 기존에는 2번 서버에 연결 되었던 키가 서버의 증설 후에는 1번 서버에 연결된다.   
만약 캐시서버를 모듈러 해싱으로 구현했다면 대규모 캐시 미스가 발생할 것이다.

### 서버의 개수를 늘리지 않을 생각이라면 이 방식을 사용해도 괜찮을까?
그렇지 않다. 만약 서버에 장애가 발생한다면 가용 서버의 개수는 1개가 줄어든다.  
그렇기 때문에 이 때에도 나눠지는 서버의 개수가 바뀌기 때문에 대규모 캐시 미스가 발생할 것이다.

그렇다면 어떻게 해결해야 할까?

## 안정 해시
해결책은 안정 해시를 사용하는 것이다. 
안정 해시를 사용하더라도 기존의 키의 위치를 전부 고정시켜 둘 수는 없다.  
대신 재배치 되는 키의 개수를 최소화하는 것이다.  
그 개수는 평균적으로 **키의 전체 개수에서 서버의 개수를 나눈 값**이다.

### 어떻게 일부만 재배치할 수 있는 것일까?
각 서버를 링 위에 배치시킨다. 그리고 저장해야 할 키 또한 링 위에 위치시킨다.  
그리고 각 키들은 시계방향으로 링을 탐색하면서 가장 가까운 서버에 저장된다.  

### 서버를 추가한다면
서버를 추가하게 된다면 가장 첫 번째 서버에 연결되던 키들의 일부가 추가된 서버에 연결된다.  

### 서버를 제거한다면
서버를 제거하더라도 시계 방향으로 탐색하면서 가장 가까운 위치의 서버에 연결된다.  

> 그렇기 때문에 서버의 추가, 삭제의 경우 일부의 키들만 재배치된다.

## 안정해시에는 문제가 없을까?
연속적인 서버가 제거된다면 제거된 서버에 할당된 키들이 하나의 서버에 전부 할당되게 되어 각 서버의 할당량이 균등하지 못하게 된다.  
이렇게 되면 캐시미스는 줄일 수 있어도 할당량이 많아진 서버의 부하가 커지게 된다.  

### 가상노드로 해결하자
이 경우에는 기존의 서버들을 복제하여 촘촘하게 파티션을 구성한다. 즉 하나의 서버가 여러 공간의 파티션을 관리하는 것이다.  
이렇게 되면 기존의 서버가 제거가 되더라도 가상 노드들로 인해 더 많은 서버를 운용하는 것처럼 관리가 되기 때문에 파티션의 불균형 문제와 키의 불균등을 막을 수 있다.  
가상노드가 많아질수록 키의 분포는 점점 균등해진다.


## 마무리
스케일 아웃을 할 때 키를 균등하게 분배하는 방법을 알게 되었다. 하지만 실제로 어떻게 구현해야할지 감이 잘 안잡힌다.  
레디스를 사용하게 되면 이후에 코드로 구현해보는 시간을 가져야 할 것 같다.