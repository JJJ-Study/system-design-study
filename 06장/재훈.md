# 6장. 키-값 저장소 설계

## 개념
키-값 저장소는 키-값 데이터베이스라고도 불리는 비관계형 데이터베이스이다.  
널리 알려진 저장소로는 레디스가 있다.  
> 레디스는 영구저장의 목적보다는 캐시 목적으로 쓰인다.

## 단일 서버
단일 서버로 키-값 저장소를 설계하는 것은 어렵지 않다.  
그냥 하나의 저장소에 데이터 전부를 저장하면 된다.

### 장점
이 방식을 채택할 경우 구현하는 것이 쉽고, 접근 속도가 빠르다는 장점이 있다.

### 단점
하지만 모든 데이터를 메모리에 두는 것은 현실적으로 불가능하다.  
왜냐하면 HDD나 SSD에 비해서 용량이 매우 작고, 비싸기 떄문이다.

### 개선책
1. 실제 데이터에 접근할 수 있는 식별자만 키-값 저장소에 저장  
    이 방식을 사용하면 적은 용량을 사용하면서도 데이터 접근 속도를 높일 수 있다.
2. 데이터 압축  
   실제 데이터를 저장하지만 압축해서 저장한다.
3. 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장  
   자주 사용하는 데이터만 메모리에 저장함으로써 메모리 공간을 효율적으로 사용할 수 있다.
> 일반적으로 1번과 3번을 많이 사용하는 것 같다.


## 분산서버
분산서버가 된다면 각 서버 사이의 데이터의 일관성을 지키는 것이 중요하다.  
또한 분산 서버에 접속하는 클라이언트는 항상 요청에 대한 응답을 받을 수 있어야한다.  
그러나 현실적으로 일관성과 가용성을 동시에 만족하는 것은 불가능하다.

## CAP
일관성(Consistency) : 어떤 서버에 접속하든 같은 데이터에 접근해야한다.  
가용성(Availability) : 언제 데이터를 요청하더라도 항상 응답받을 수 있어야 한다.  
파티션 감내(Partition tolerance) : 여러 서버 사이의 단절이 생겨도 시스템이 여전히 동작해야한다.  
_여기서 파티션은 나누는다는 의미가 아나고 장애상황(네트워크의 분절)이라는 것을 의미한다._

### 3가지를 한번에 만족할 수는 없다.
이 3가지의 특성은 동시에 만족하는 것은 불가능하다.  
이들 가운데 최대 2가지의 특성만 만족할 수 있다.  

어떤 서비스를 운영할 때 파티션 문제는 피할 수 없다. 즉, 장애의 상황은 피할 수 없다.  
이 때 장애가 발생했다고 해서 서비스를 중단하면은 안 될것이다.  
그러므로 `파티션 감내`는 반드시 할 수 있도록 설계해야한다.  

그렇다면 파티션 감내가 필수인 상황에서 일관성을 지켜는 상황을 생각해보자.  
장애 발생에 의해서 서버 사이의 통신이 중단된다면 데이터의 일관성을 지키기 위해서 오래된 데이터의 접근은 통제해야한다.  
이렇게 되면 가용성은 지킬 수 없다.  

파티션 감내가 필수인 상황에서 가용성을 지키는 상황을 생각해보자.  
장애 발생에 의해서 서버 사이의 통신이 중단되면 데이터의 동기화가 되지 않는다.  
이 상황에서 가용성을 지킨다면 항상 데이터에 접근할 수 있어야 하는데 동기화 되지 않은 데이터에 접근할 경우 일관성을 지킬 수 없다.  

> 파티션의 상황 발생할 수 밖에 없으므로 3가지를 한번에 만족할 수는 없다. 

## 분산서버에 적용해야 할 기술
### 데이터 파티션
이 부분에 대해서는 5장 안정해시에서 다루었다.  
안정해시를 사용하면 데이터를 안정적으로 분산하여 데이터를 접근 및 조작할 수 있다.

### 데이터 다중화
안정적인 데이터 활용을 위해 여러 서버에 데이터를 저장할 필요가 있다.  
안정해시를 사용하는 경우 키가 만나는 첫번째 서버로부터 연속적인 일정갯수의 서버에 같은 데이터를 저장하면 된다.  
그런데 안정해시에 가상 노드가 포함되는 경우 같은 서버가 중복으로 선택될 수 있는데 이 부분을 고려하여 다중화를 해야한다.

### 데이터 일관성
분산서버에서 모든 서버의 데이터가 같을 때를 기준으로 일관성을 판단하면 비효율적일 것이다.  
그래서 정족수 합의를 통해 데이터 일관성의 수준을 조절할 수 있다.  
> 정족수 합의란 일정 사본 개수의 이상이 쓰기 연산 혹은 읽기 연산에 성공한 것으로 간주되어야 응답을 받을 수 있다는 것이다. 
 
#### 쓰기 정족수
N개의 노드들에 데이터 쓰기 연산이 완료되어야 성공했다는 응답을 보낸다.

#### 읽기 정족수
N개의 노드들에 데이터 읽기 연산이 완료되어야 성공했다는 응답을 보낸다.

#### 중재자
각 노드들 앞단에 중재자를 두고 클라이언트의 요청을 받아서 각 노드들에게 요청을 전달한다.  
정족수만큼의 응답이 돌아오면 클라이언트에게 응답을 보내게 된다.

### 일관성 모델
- 강한 일관성  
  클라이언트는 절대로 낡은 데이터를 읽지 못한다. 즉, 모든 노드들에 쓰기 연산이 반영될 때까지 읽기/쓰기를 못한다.  
  가용성이 낮기 때문에 현실적으로 채택하기 어려운 모델이다.
- 약한 일관성  
  읽기 연산이 최신 데이터를 반환하지 못할 수도 있는 일관성이다.  
  일관성과 가용성의 균형을 맞춘 모델이다. 일반적으로 이 모델을 사용한다.
- 결과적 일관성  
  약한 일관성의 한 종류로 일관성 문제의 책임을 클라이언트측에게 주는 것이다.  
  클라이언트는 데이터의 버전 정보를 통해 일관성이 깨진 데이터를 읽지 않을 수 있다.

### 결과적 일관성에서 비 일관성 해소법
데이터에 버전을 부여하고 충돌이 발생한 경우 충돌 해소의 책임을 클라이언트에게 주는 방법이다.  
이 방식은 충돌 감지와 해소의 로직이 클라이언트에 들어가게 돼서 구현이 복잡해지는 단점이 있다.  
또한 [서버:버전]의 개수는 빨리 늘어나서 저장해야 하는 순서쌍의 개수가 많다.  
그래서 임계치를 정해두고 오래된 순서쌍을 삭제해야하는데 그렇게 되면 버전 선후관계를 정확하게 결정할 수 없게 된다.  
하지만 결과적 일관성을 채택한 실제 서비스에서 선후관계의 문제가 생기는 현상은 발견한 적이 없다고 한다.  
그러므로 논리적으로는 문제가 생길수 있지만 현실적으로는 이상이 없다는 결론이 도출되어 이 방식은 괜찮은 솔루션으로 평가받는다.

## 장애 감지
분산 시스템에서 보통 두 대 이상의 서버가 똑같이 장애서버 보고를 해야 실제로 장애가 발생했다고 간주한다.  
장애를 발견하는 가장 손쉬운 방법은 각 노드 사이에 멀티캐스팅 채널을 구축하는 것인데 이것은 비효율적이다.  
모든 노드들의 보고를 주기적으로 받아야 할 것이기 떄문이다.  
더 좋은 해결책이 있다.  

### 가십 프로토콜
각 노드들과 박동카운터를 한 쌍으로 목록을 만든다. 그리고 목록을 각 노드들이 가지고 있다.  
각 노드들은 주기적으로 자신의 박동카운터를 증가시킨다.  
그리고 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터를 보내게 된다.  
이 때 장애가 발생한 노드의 박동 카운터는 갱신이 안되기 때문에 지정한 시간동안 갱신이 되지 않을 때 장애 노드로 판단한다.

## 장애 처리
장애를 감지했으면 처리 하는 방법도 알아보자

### 일시적 장애 처리
일시적으로 서버에 문제가 생긴 경우라면 다른 서버에서 장애 서버로 가는 요청을 잠시 맡아 처리하고, 서버가 복구될 때 일괄 반영한다.  
이를 위해서 임시로 데이터를 쓰기로한 서버에 그와 관련된 단서들을 남긴다. 이 방식을 `단서 후 임시 위탁기법`이라고 한다.

### 영구 장애 처리
영구 장애의 경우에는 `단서 후 임시 위탁기법`을 사용할 수 없다. 장애 복구가 안되기 때문이다.  
반엔트로피 프로토콜을 통해 데이터를 최신 상태로 갱신하고, 장애 서버로의 데이터 전송을 줄이는 방법으로 머클트리를 사용한다.

> 영구 장애 처리에 쓰이는 반엔트로피 프로토콜과 머클트리를 아직 잘 모르겠다. 추후에 더 공부해봐야겠다